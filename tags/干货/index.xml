<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>干货 on KanataRoom</title>
    <link>https://nick-cjyx9.github.io/tags/%E5%B9%B2%E8%B4%A7/</link>
    <description>Recent content in 干货 on KanataRoom</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2022–2023, Nick Chen; all rights reserved.</copyright>
    <lastBuildDate>Fri, 13 Jan 2023 22:08:59 +0800</lastBuildDate><atom:link href="https://nick-cjyx9.github.io/tags/%E5%B9%B2%E8%B4%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ybt_1442_拼棍子</title>
      <link>https://nick-cjyx9.github.io/post/ybt_1442_%E6%8B%BC%E6%A3%8D%E5%AD%90/</link>
      <pubDate>Fri, 13 Jan 2023 22:08:59 +0800</pubDate>
      
      <guid>https://nick-cjyx9.github.io/post/ybt_1442_%E6%8B%BC%E6%A3%8D%E5%AD%90/</guid>
      <description>【题目直达】 信息学奥赛一本通（C++版）在线评测系统 (ssoier.cn)
https://www.luogu.com.cn/problem/P1120
【tips】 ybt和lg是一样的题目，但是数据不同，ybt需要排除长度大于50的棍子，lg规定了范围不用排
【题目描述】 乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过50。现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。
【输入】 第一行为一个单独的整数N表示砍过以后的小木棍的总数，其中N≤60，第二行为N个用空个隔开的正整数，表示N根小木棍的长度。
【输出】 仅一行，表示要求的原始木棍的最小可能长度。
【输入样例】 9 5 2 1 5 2 1 5 2 1 【输出样例】 6 【题解】 #include &amp;lt;bits/stdc++.h&amp;gt; int cnt,N,stk[70],tot,maxn=-1; bool vis[70];int nxt[1000]; template&amp;lt;typename L&amp;gt; inline void Read(L &amp;amp;X){ //tip0：快读 char c=getchar();L zhi=0,fu=1; while(not isdigit(c)){if(c==&amp;#39;-&amp;#39;)fu=-1;c=getchar();} while(isdigit(c)){zhi=(zhi&amp;lt;&amp;lt;1)+(zhi&amp;lt;&amp;lt;3)+c-&amp;#39;0&amp;#39;;c=getchar();} X=fu*zhi; } inline void dfs(int its,int sum,int len){ //爆搜思路 its:上一根拼接的棍子 sum：已拼棍子的长度 len：目标长度 if(sum+stk[its]==len){ //已完成此根拼接 for(int j=1;j&amp;lt;=N;j++){ //去找下一根的头，同样tip2：从头找以保证最长 if(vis[j]==0){ vis[j]=1; dfs(j,0,len); vis[j]=0; //tip3：vis存储家访过的棍棍，方便回溯 return ; } }std::cout&amp;lt;&amp;lt;len;exit(0); //tip1：找不到就说明已完成所有工作，输出答案后立即退出，不做多余搜索 }else if(sum+stk[its]&amp;lt;len) for(int i=its+1;i&amp;lt;=N;i++){ //tip2：此处从下一根开找，保证从大到小拼接 if(vis[i]==0&amp;amp;&amp;amp;stk[its]+stk[i]+sum&amp;lt;=len){ vis[i]=1; dfs(i,sum+stk[its],len); vis[i]=0; //tip3 if(len-sum-stk[its]==stk[i]||sum==0)return ; /*tip4：其实我当时也没想明白这个，所以借lg题解区： 如果当前长棍剩余的未拼长度等于当前木棍的长度或原始长度，继续拼下去时却失败了，就直接回溯并改之前拼的木棍。 当前长棍剩余的未拼长度等于当前木棍的长度时，这根木棍在最优情况下显然是拼到这（如果用更多短木根拼完剩下的这段，把这根木棍留到后面显然不如把更多总长相等的短木棍扔到后面）。如果在最优情况下继续拼下去失败了，那肯定是之前的木棍用错了，回溯改即可。 原来的长棍还一点没拼时，现在正在放入一根木棍。很明显，这根木棍还没有跟其它棍子拼接，如果现在拼下去能成功话，它肯定是能用上的，即自组或与其它还没用的木棍拼接。但继续拼下去却失败，说明现在这根木棍不能用上，无法完成拼接，所以回溯改之前的木棍。 */ i=nxt[i]; if(i==N)return ; //tip5：这个长度本来就不行了，不能再用一样长度的了，直接跳到比它小的第一个去 } } } bool cmp(int a,int b){return a&amp;gt;b;} int main(){ Read(cnt);int temp; for(int i=1;i&amp;lt;=cnt;i++){ //非法数据处理 Read(temp); if(temp&amp;lt;=50){ stk[++N]=temp; tot+=stk[N]; if(stk[N]&amp;gt;maxn)maxn=stk[N]; } } std::sort(stk+1,stk+N+1,cmp); //tip2：从大到小排序 nxt[N]=N; for(int i=N-1;i&amp;gt;0;i--){ if(stk[i]==stk[i+1]) nxt[i]=nxt[i+1]; else nxt[i]=i; } for(int i=maxn;i&amp;lt;=tot;i++){ if(tot%i!</description>
    </item>
    
    <item>
      <title>Ybt_1220_单词接龙</title>
      <link>https://nick-cjyx9.github.io/post/ybt_1220_%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</link>
      <pubDate>Thu, 12 Jan 2023 16:26:41 +0800</pubDate>
      
      <guid>https://nick-cjyx9.github.io/post/ybt_1220_%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</guid>
      <description>【题目直达】 http://ybt.ssoier.cn:8088/problem_show.php?pid=1220
【题目描述】 单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和atide间不能相连。
【输入】 输入的第一行为一个单独的整数n(n&amp;lt;=20)表示单词数，以下n行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。
【输出】 只需输出以此字母开头的最长的“龙”的长度。
【输入样例】 5 at touch cheat choose tact a 【输出样例】 23 【题解】 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int n,hans;char words[30][30],key; //定义存储变量 short vis[30],DEBUG=0; //每个单词都最多在“龙”中出现两次，使用short类型vis数组 template&amp;lt;typename L&amp;gt; inline void logr(L a){ if(DEBUG)cout&amp;lt;&amp;lt;a; } //debug控制是否输出过程变量（就是调试） inline int coin(char a[],char b[]){ /* coin(char[],char[])-&amp;gt;int 判断形参a，b是否能首尾相接， 返回重合部分大小 */ int i=strlen(a)-1,j=0; while(1){ if(j==strlen(b)) return 0; //超出边界，尚未搜到a串尾字母 if(a[i]==b[j]){ //从标记点回搜 int ans=1; for(int o=j-1;o&amp;gt;=0;o--){ if(b[o]!=a[i-j+o])return 0; ans++; //不重合一票否决 } return (ans!=strlen(a)&amp;amp;&amp;amp;ans!=strlen(b))?ans:0; //对于coin(&amp;#34;at&amp;#34;,&amp;#34;atide&amp;#34;)此类的特判 } j++; } } inline void dfs(int h,int cnt){ if(cnt&amp;gt;hans)hans=cnt; //更新答案 for(int i=1;i&amp;lt;=n;i++){ int coinn=coin(words[h],words[i]); //遍历，&amp;#34;找尾巴&amp;#34; if(coinn!</description>
    </item>
    
    <item>
      <title>Hugo建站经验</title>
      <link>https://nick-cjyx9.github.io/post/hugo%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Sun, 08 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://nick-cjyx9.github.io/post/hugo%E5%BB%BA%E7%AB%99%E7%BB%8F%E9%AA%8C/</guid>
      <description>第一点hugo的版本一定要新，很多主题在老版本报错 第二在hugo new xxx.md时，使用的front matter 默认使用---分割线和类似json的写法，这里推荐换作+++，默认配置在/archetypes/default.md修改，附上个人配置: +++ author= &amp;#34;cjyx9&amp;#34; title= &amp;#34;{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}&amp;#34; date= &amp;#34;{{ .Date }}&amp;#34; tags= [ &amp;#34;&amp;#34;, ] +++ 个人认为网站更新部署过程繁琐，写了3个bat脚本，附上（置于blog的根目录） newPost.bat @echo off set /p name=Enter post name: set /p in=R U sure it&amp;#39;s %name%?(press enter to continue,ctrl+c to exit) hugo new /post/%name%.md E:\Typora\Typora.exe E:/gayhub/blog/content/post/%name%.md set /p in=Press `enter` to apply. ::这两行可不写 deploy.bat
cd E:/gayhub/blog hugo -D cd public git add .</description>
    </item>
    
  </channel>
</rss>
